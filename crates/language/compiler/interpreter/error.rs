use std::{
  hash::Hash,
  string::{FromUtf16Error, FromUtf8Error},
};

/// Wrapper of Result that can handle various error types
pub type RumResult<T> = Result<T, RumScriptError>;

/// Stores every error type that can be generated by a radlr function. Also
/// wraps common error types.
#[derive(Clone, Hash)]
pub enum RumScriptError {
  ParseError(radlr_rust_runtime::types::ParserError),
  Multi(Vec<RumScriptError>),
  /// Error from a poisoned pointer.
  PoisonError(String),
  /// Error from an IO operation
  IOError(String),
  /// Generic error
  Error(std::fmt::Error),
  /// Plaintext error message
  Text(String),
  /// Plaintext error message
  StaticText(&'static str),
}
use RumScriptError::*;

impl IntoIterator for RumScriptError {
  type IntoIter = std::vec::IntoIter<Self::Item>;
  type Item = RumScriptError;

  fn into_iter(self) -> Self::IntoIter {
    match self {
      Multi(errors) => errors.into_iter(),
      err => vec![err].into_iter(),
    }
  }
}

impl RumScriptError {
  /// Compares the friendly name of an error with a string,
  /// returning `true` if the two match.
  pub fn is(&self, _friendly_name: &str) -> bool {
    match self {
      _ => false,
    }
  }

  pub fn flatten(self) -> Vec<RumScriptError> {
    match self {
      Multi(errors) => errors.into_iter().flat_map(|e| e.flatten()).collect(),
      err => vec![err],
    }
  }

  /// Flattens errors in to a single error type. If the nested level of errors
  /// is 1 and only a single error in that level, that error is returned,
  /// otherwise a flattened Multi error is returned.
  pub fn flattened_multi(self) -> RumScriptError {
    match self {
      Multi(errors) => Multi(errors.into_iter().flat_map(|e| e.flatten()).collect()),
      err => err,
    }
  }
}

impl From<radlr_rust_runtime::types::ParserError> for RumScriptError {
  #[track_caller]
  fn from(err: radlr_rust_runtime::types::ParserError) -> Self {
    Self::ParseError(err)
  }
}

impl From<std::io::Error> for RumScriptError {
  #[track_caller]
  fn from(err: std::io::Error) -> Self {
    IOError(err.to_string())
  }
}

impl From<std::fmt::Error> for RumScriptError {
  #[track_caller]
  fn from(err: std::fmt::Error) -> Self {
    Self::Error(err)
  }
}

impl From<()> for RumScriptError {
  #[track_caller]
  fn from(_: ()) -> Self {
    "UNDEFINED".into()
  }
}

impl From<&str> for RumScriptError {
  #[track_caller]
  fn from(err: &str) -> Self {
    Text(err.to_string())
  }
}

impl From<String> for RumScriptError {
  #[track_caller]
  fn from(err: String) -> Self {
    Text(err)
  }
}

impl From<FromUtf8Error> for RumScriptError {
  #[track_caller]
  fn from(err: FromUtf8Error) -> Self {
    Text(err.to_string())
  }
}

impl From<FromUtf16Error> for RumScriptError {
  #[track_caller]
  fn from(err: FromUtf16Error) -> Self {
    Text(err.to_string())
  }
}

impl std::fmt::Display for RumScriptError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    std::fmt::Debug::fmt(&self, f)
  }
}

impl From<std::ffi::NulError> for RumScriptError {
  #[track_caller]
  fn from(_value: std::ffi::NulError) -> Self {
    RumScriptError::StaticText("interior null byte found")
  }
}

impl std::fmt::Debug for RumScriptError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      PoisonError(err_string) => f.write_fmt(format_args!("\nPoison Error: {}", err_string)),
      IOError(err_string) => f.write_fmt(format_args!("\nIO Error: {}", err_string)),
      Text(err_string) => f.write_str(&err_string),
      StaticText(err_string) => f.write_str(err_string),
      Self::Error(error) => std::fmt::Debug::fmt(error, f),
      Multi(errors) => {
        let f = f;
        for error in errors {
          std::fmt::Debug::fmt(error, f)?;
        }
        std::fmt::Result::Ok(())
      }
      _ => std::fmt::Result::Ok(()),
    }
  }
}

#[derive(Default)]
#[cfg_attr(any(debug_assertions, auto_print_errors), derive(std::fmt::Debug))]
pub struct ErrorGroups {
  pub hints:    Vec<RumScriptError>,
  pub warnings: Vec<RumScriptError>,
  pub critical: Vec<RumScriptError>,
}

pub trait ErrorContainerIter: Iterator<Item = RumScriptError> + Sized + Clone {
  fn _debug_print_(&self) {
    for error in self.clone() {
      eprintln!("{:?}", error);
    }
  }

  fn stderr_print(&self) {
    for error in self.clone() {
      eprintln!("{:?}", error);
    }
  }

  fn have_errors(&self) -> bool {
    self.clone().count() == 0
  }

  fn flatten(self) -> Vec<RumScriptError> {
    let mut out = Vec::default();
    for err in self {
      out.extend(err.flatten());
    }

    out
  }

  fn into_multi(self) -> RumScriptError {
    RumScriptError::Multi(Vec::from_iter(self))
  }
}

impl<T: Iterator<Item = RumScriptError> + Sized + Clone> ErrorContainerIter for T {}
